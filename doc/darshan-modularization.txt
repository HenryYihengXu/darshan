Darshan modularization branch development notes
===============================================

== Introduction

Darshan is a lightweight toolkit for characterizing the I/O performance of instrumented
HPC applications.

Darshan was originally designed to gather I/O data from a static set of sources.
Adding instrumentation for additional sources of I/O data was only possible through
manual modification of the Darshan log file format, which consequentially breaks
any other utilities reliant on that format.

Starting with version 3.0.0, the Darshan runtime environment and log file format have
been redesigned such that new "instrumentation modules" can be added without breaking
existing tools. Developers are given a framework to implement arbitrary instrumentation
modules, which are responsible for gathering I/O data from a specific system component
(which could be from an I/O library, platform-specific data, etc.). Darshan can then
manage these modules at runtime and create a valid Darshan log regardless of how many
or what types of modules are used.

== Checking out and building the modularization branch

Developers can clone the Darshan source repository using the following methods:

* "git clone git://git.mcs.anl.gov/radix/darshan" (read-only access)

* "git clone \git@git.mcs.anl.gov:radix/darshan" (authenticated access)

After cloning the Darshan source, it is necessary to checkout the modularization
development branch:

----
git clone git@git.mcs.anl.gov:radix/darshan
git checkout dev-modular
----

For details on configuring and building the Darshan runtime and utility repositories,
consult the documentation from previous versions
(http://www.mcs.anl.gov/research/projects/darshan/docs/darshan-runtime.html[darshan-runtime] and
http://www.mcs.anl.gov/research/projects/darshan/docs/darshan-util.html[darshan-util]) -- the
necessary steps for building these repositories should not have changed in the new version of
Darshan.

== Darshan dev-modular overview

The Darshan source tree is organized into two primary components:

* *darshan-runtime*: Darshan runtime environment necessary for instrumenting MPI
applications and generating I/O characterization logs.

* *darshan-util*: Darshan utilities for analyzing the contents of a given Darshan
I/O characterization log.

The following subsections provide an overview of each of these components with specific
attention to how new instrumentation modules may be integrated into Darshan.

=== Darshan-runtime

The primary responsibilities of the darshan-runtime component are:

* intercepting I/O functions of interest from a target application;

* extracting statistics, timing information, and other data characterizing the application's I/O workload;

* compressing I/O characterization data and corresponding metadata;

* logging the compressed I/O characterization to file for future evaluation

The first two responsibilities are the burden of the instrumentation module developer, while the last
two are handled automatically by Darshan.

==== Instrumentation modules

The wrapper functions used to intercept I/O function calls of interest are central to the design of
any Darshan instrumentation module. These wrappers are used to extract pertinent I/O data from
the function call and persist this data in some state structure maintained by the module. The wrappers
are inserted at compile time for statically linked executables (e.g., using the linkers `--wrap`
mechanism) and at runtime for dynamically linked executables (using LD_PRELOAD).

*NOTE*: Modules should not perform any I/O or communication within wrapper functions. Darshan records
I/O data independently on each application process, then merges the data from all processes when the
job is shutting down. This defers expensive I/O and communication operations to the shutdown process,
limiting Darshan's impact on application I/O performance.

When the instrumented application terminates and Darshan begins its shutdown procedure, it requires
a way to interface with any active modules that have data to contribute to the output I/O characterization.
Darshan requires that module developers implement the following functions to allow the Darshan runtime
environment to coordinate with modules while shutting down:

[source,c]
struct darshan_module_funcs
{
    void (*disable_instrumentation)(void);
    void (*prepare_for_reduction)(
        darshan_record_id *shared_recs,
        int *shared_rec_count,
        void **send_buf,
        void **recv_buf,
        int *rec_size
    );
    void (*reduce_records)(
        void* a,
        void* b,
        int *len,
        MPI_Datatype *datatype
    );
    void (*get_output_data)(
        void** buf,
        int* size
    );
    void (*shutdown)(void);
};

`disable_instrumentation()`

This function informs the module that Darshan is about to begin shutting down. It should disable
all wrappers and stop updating internal data structures to ensure data consistency and avoid
other race conditions.

`prepare_for_reduction()`

Since Darshan aggregates shared data records (i.e., records which all application processes
accessed) into a single record, module developers must provide mechanisms for performing a reduction
on these records.

This function is used to prepare a module for performing a reduction operation. In general, this
just involves providing the input buffers to the reduction, and (on rank 0 only) providing output
buffer space to store the result of the reduction.

* _shared_recs_ is a set of Darshan record identifiers which are associated with this module.
These are the records which need to be reduced into single shared data records.

* _shared_rec_count_ is a pointer to an integer storing the number of shared records will
be reduced by this module. When the function is called this variable points to the number
of shared records detected by Darshan, but the module can decide not to reduce any number
of these records. Upon completion of the function, this variable should point to the number
of shared records to perform reductions on (i.e., the size of the input and output buffers).

* _send_buf_ is a pointer to the address of the send buffer used for performing the reduction
operation. Upon completion, this variable should point to a buffer containing *_shared_rec_count_
records that will be reduced.

* _recv_buf_ is a pointer to the address of the receive bufffer used for performing the reduction
operation. Upon completion, this variable should point to a buffer containing *_shared_rec_count_
records that will be reduced. This variable is only valid on the root process (rank 0). This
buffer address needs to be stored with module state, as it will be needed when retrieiving
the final output buffers from this module.

* _rec_size_ is just the size of the record structure being reduced for this module.

`reduce_records()`

This is the function which performs the actual shared record reduction operation. The prototype
of this function matches that of the user function provided to the MPI_Op_create function. Refer
to the http://www.mpich.org/static/docs/v3.1/www3/MPI_Op_create.html[documentation] for further
details.

`get_output_data()`

This function is responsible for passing back a single buffer storing all data this module is
contributing to the output I/O characterization. On rank 0, this may involve copying the results
of the shared record reduction into the output buffer.

* _buf_ is a pointer to the address of the buffer this module is contributing to the I/O
characterization. 

* _size_ is the size of this module's output buffer.

`shutdown()`

This function is a signal from Darshan that it is safe to shutdown. It should clean up and free
all internal data structures.

==== darshan-core

Within darshan-runtime, the darshan-core component manages the initialization and shutdown of the
Darshan environment, provides instrumentation module developers an interface for registering modules
with Darshan, and manages the compressing and the writing of the resultant I/O charracterization.
Each of the functions defined by this interface are explained in detail below.

[source,c]
void darshan_core_register_module(
    darshan_module_id mod_id,
    struct darshan_module_funcs *funcs,
    int *runtime_mem_limit);

The `darshan_core_register_module` function registers Darshan instrumentation modules with the
darshan-core runtime environment. This function needs to be called at least once for any module
that will contribute data to Darshan's final I/O characterization. 

* _mod_id_ is a unique identifier for the given module, which is defined in the Darshan log
format header file (darshan-log-format.h).

* _funcs_ is the structure of function pointers (as described above) that a module developer must
provide to interface with the darshan-core runtime. 

* _runtime_mem_limit_ is a pointer to an integer which will store the amount of memory Darshan
allows this module to use at runtime. Currently, darshan-core will hardcode this value to 2 MiB,
but in the future this may be changed to optimize Darshan's memory footprint. Note that Darshan
does not allocate any memory for modules, it just informs a module how much memory it can use.

[source,c]
void darshan_core_unregister_module(
    darshan_module_id mod_id);

The `darshan_core_unregister_module` function disassociates the given module from the
darshan-core runtime. Consequentially, Darshan does not interface with the given module at
shutdown time and will not log any I/O data from the module. This function should only be used
if a module registers itself with darshan-core but later decides it does not want to contribute
any I/O data.

* _mod_id_ is the unique identifer for the module being unregistered.

[source,c]
void darshan_core_register_record(
    void *name,
    int len,
    int printable_flag,
    darshan_module_id mod_id,
    darshan_record_id *rec_id);

The `darshan_core_register_record` function registers some data record with the darshan-core
runtime. This record could reference a POSIX file or perhaps an object identifier for an
object storage system, for instance.  A unique identifier for the given record name is
generated by Darshan, which should then be used by the module for referencing the corresponding
record.  This allows multiple modules to refer to a specific data record in a consistent manner
and also provides a mechanism for mapping these records back to important metadata stored by
darshan-core. It is safe (and likely necessary) to call this function many times for the same
record -- darshan-core will just set the corresponding record identifier if the record has
been previously registered.

* _name_ is just the name of the data record, which could be a file path, object ID, etc.

* _len_ is the size of the input record name. For string record names, this would just be the
string length, but for nonprintable record names (e.g., an integer object identifier), this
is the size of the record name type.

* _printable_flag_ indicates whether the input record name is a printable ASCII string.

* _mod_id_ is the identifier for the module attempting to register this record.

* _rec_id_ is a pointer to a variable which will store the unique record identifier generated
by Darshan.

[source,c]
void darshan_core_unregister_record(
    darshan_record_id rec_id,
    darshan_module_id mod_id);

The `darshan_core_unregister_record` functoin disassociates the given module identifier from the
given record identifier. If no other modules are associated with the given record identifier, then
Darshan removes all internal references to the record. This function should only be used if a
module registers a record with darshan-core, but later decides not to store the record internally.

* _rec_id_ is the record identifier we want to unregister.

* _mod_id_ is the module identifier that is unregistering _rec_id_.

[source,c]
double darshan_core_wtime(void);

The `darshan_core_wtime` function simply returns a floating point number of seconds since
Darshan was initialized. This functionality can be used to time the duration of application
I/O calls or to store timestamps of when functions of interest were called.

==== darshan-common

darshan-common is a utility component of darshan-runtime, providing module developers with
general functions that are likely to be reused across multiple modules. These functions are
distinct from darshan-core functions since they do not require access to internal Darshan
state.

[source,c]
char* darshan_clean_file_path(
    const char* path);

The `darshan_clean_file_path` function just cleans up the input path string, converting
relative paths to absolute paths and suppressing any potential noise within the string.
The address of the new string is returned and should be freed by the user.

* _path_ is the input path string to be cleaned up.

As more modules are contributed, it is likely that more functionality can be refactored out
of module implementations and maintained in darshan-common, facilitating code reuse and
simplifying maintenance.

=== Darshan-util

The darshan-util component is composed of a log parsing library (libdarshan-util) and a
corresponding set of utility programs that can parse and analyze Darshan I/O characterization
logs using this library. The log parsing library includes a generic interface (see
`darshan-logutils.h`) for retrieving specific portions of a given log file. Specifically,
this interface allows utilities to retrieve a log's header metadata, job details, record
identifier mapping, and any module-specific data contained within the log.

Module developers may wish to define additional interfaces for parsing module-specific data
that can then be integrated into the log parsing library. This extended functionality can be
implemented in terms of the generic functions offered by darshan-logutils and by module-specific
formatting information.

==== darshan-logutils

Here we define each function of the `darshan-logutils` interface, which can be used to implement
new log analysis utilities and to define module-specific functionality.

[source,c]
darshan_fd darshan_log_open(const char *name, const char* mode);

Opens Darshan log file stored at path `name`. `mode` can only be `r` for reading or `w` for
writing. Returns a Darshan file descriptor on success, or `NULL` on error.

[source,c]
int darshan_log_getheader(darshan_fd fd, struct darshan_header *header);

Fills in `header` structure from the log file referenced by descriptor `fd`. The `darshan_header`
structure is defined in `darshan-log-format.h`. Returns `0` on success, `-1` on failure.

[source,c]
int darshan_log_getjob(darshan_fd fd, struct darshan_job *job);

Fills in `job` structure from the log file referenced by descriptor `fd`. The `darshan_job`
structure is defined in `darshan-log-format.h`. Returns `0` on success, `-1` on failure.

[source,c]
int darshan_log_getexe(darshan_fd fd, char *buf);

Fills in `buf` with the corresponding executable string (exe name and command line arguments)
for the Darshan log referenced by `fd`. Returns `0` on success, `-1` on failure.

[source,c]
int darshan_log_getmounts(darshan_fd fd, char*** mnt_pts, char*** fs_types, int* count);

Returns mounted file system information for the Darshan log referenced by `fd`. `mnt_pnts` points
to an array of strings storing mount points, `fs_types` points to an array of strings storing file
system types (e.g., ext4, nfs, etc.), and `count` points to an integer storing the total number
of mounted file systems recorded by Darshan. Returns `0` on success, `-1` on failure.

[source,c]
int darshan_log_gethash(darshan_fd fd, struct darshan_record_ref **hash);

Builds hash table of Darshan record identifiers to full names for all records contained
in the Darshan log referenced by `fd`. `hash` is a pointer to the hash table (of type
struct darshan_record_ref *, which should be initialized to `NULL`). This hash table is
defined by the `uthash` hash table implementation and includes corresponding macros for
searching, iterating, and deleting records from the hash. For detailed documentation on using this
hash table, consult `uthash` documentation in `darshan-util/uthash-1.9.2/doc/txt/userguide.txt`.
The `darshan-posix-parser` utility (for parsing POSIX module information out of a Darshan log)
provides an example of how this hash table may be used. Returns `0` on success, `-1` on failure.

[source,c]
int darshan_log_get_moddat(darshan_fd fd, darshan_module_id mod_id, void *moddat_buf, int moddat_buf_sz);

Retrieves a chunk of (uncompressed) data for the module identified by `mod_id` from the Darshan log
referenced by `fd`. `moddat_buf_sz` specifies the number of uncompressed bytes to read from the file
and store in `moddat_buf`. This function may be repeatedly called to retrieve sequential chunks of data
from a given Darshan file descriptor. This function returns `1` if `moddat_buf_sz` bytes were read
successfully, `0` if no more data is available for this module, and `-1` otherwise.

*NOTE*: Darshan use a reader makes right conversion strategy to rectify endianness issues
between the machine a log was generated on and a machine analyzing the log. Accordingly,
module-specific log utility functions will need to check the `swap_flag` variable of the Darshan
file descriptor to determine if byte swapping is necessary. 32-bit and 64-bit byte swapping
macros (DARSHAN_BSWAP32/DARSHAN_BSWAP64) are provided in `darshan-logutils.h`.

[source,c]
void darshan_log_close(darshan_fd fd);

Close Darshan file descriptor `fd`. Returns `0` on success, `-1` on failure.

== Adding new instrumentation modules

In this section we outline each step necessary to adding a module to Darshan.

=== Log format headers

The following modifications to Darshan log format headers are required for defining
the module's record structure:

* Add module identifier to darshan_module_id enum and add module string name to the
darshan_module_name array in `darshan-log-format.h`.

* Add a top-level header that defines a data record structure for the module. An exemplar
log header for the POSIX instrumentation module is given in `darshan-posix-log-format.h`.

=== Darshan-runtime

==== Build modifications

The following modifications to the darshan-runtime build system are necessary to integrate
new instrumentation modules:

* Necessary linker flags for wrapping this module's functions need to be added to the definition
of `CP_WRAPPERS` in `darshan-config.in`.

* Targets must be added to `Makefile.in` to build static and shared objects for the module's
source files, which will be stored in the `lib/` directory. The prerequisites to building
static and dynamic versions of `lib-darshan` must be updated to include these objects, as well.

==== Instrumentation module implementation

An exemplar instrumentation module for POSIX I/O functions is given in `lib/darshan-posix.c` as
reference. In addtion to the development notes from above and the reference POSIX module, we
provide the following notes to assist module developers:

* Modules only need to include the `darshan.h` header to interface with darshan-core.

* Lacking a way to bootstrap themselves, modules will have to include some logic in their
wrappers to initialize necessary module state if initialization has not already occurred.
    - Part of this initialization process should be registering the module with darshan-core,
    since this informs the module how much memory it may allocate.

* The file record identifier given when registering a record with darshan-core can be used
to store the record structure in a hash table or some other structure.
    - The `darshan_core_register_record` function is really more like a lookup function. It
    may be called multiple times for the same record -- if the record already exists, the function
    simply returns its record ID.
    - It may be necessary to maintain a separate hash table for other handles which the module
    may use to refer to a given record. For instance, the POSIX module may need to look up a
    file record based on a given file descriptor, rather than a path name.

=== Darshan-util

==== Build modifications

The following modifications to the darshan-util build system are necessary to integrate new
instrumentation modules:

* Update `Makefile.in` with new targets necessary for building new utilities and module-specific
log parsing source.
    - Make sure to update `all`, `clean`, and `install` targets to reference updates.
    - If adding new log parsing functionality, make sure to add it as a prerequisite source for 
    building libdarshan-util.

==== Module-specific logutils and utilities

For a straightforward reference implementation of module-specific log parsing functionality for
the POSIX module, consider files `darshan-posix-logutils.c` and `darshan-posix-logutils.h`. 

Also, the `darshan-posix-parser` source provides a simple example of a utility which can leverage
libdarshan-util for analyzing the contents of a given Darshan I/O characterization log.

== Other resources

* http://www.mcs.anl.gov/research/projects/darshan/[Darshan website]
* http://www.mcs.anl.gov/research/projects/darshan/docs/darshan-runtime.html[darshan-runtime documentation]
* http://www.mcs.anl.gov/research/projects/darshan/docs/darshan-util.html[darshan-util documentation]
* https://lists.mcs.anl.gov/mailman/listinfo/darshan-users[Darshan-users mailing list]
* https://trac.mcs.anl.gov/projects/darshan/report[Darshan trac page]
