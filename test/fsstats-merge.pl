#!/usr/bin/perl -w
#
#  (C) 2010 by Argonne National Laboratory.
#
#  Routines for handling human readable sizes and percentages
#  TODO: what else?
#  Copyright (c) 2005 Panasas, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#   
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#   
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

use Cwd;
use Getopt::Long;
use English;

# files to process
my @csv_files = ();

process_args();

my $special_files = 0;
my $skipped_hlink = 0;
my $skipped_snapshot = 0;
my $total_cap_used = 0;
my $total_size = 0;

# loop through specified csv files
foreach my $file ( @csv_files )
{
    open(CSV, "$file") || die("Error opening file $file: $!\n");

    add_summary(CSV);

    close(CSV);
}

print_output();

exit 0;

sub print_output
{
    printf("#Generated by fsstats-merge.pl (fsstats v1.4.5)\n");
    printf("#Comment: This is a comment line that can be modified or repeated before\n");
    printf("#uploading to record voluntarily added information.\n\n");

    printf("skipped special files,%d\n", $special_files);
    printf("skipped duplicate hardlinks,%d\n", $skipped_hlink);
    printf("skipped snapshot dirs,%d\n", $skipped_snapshot);
    printf("total capacity used,%s\n", kb_to_print($total_cap_used));
    printf("total user data,%s\n", kb_to_print($total_size));
    printf("percent overhead,%f\n", ovhd_pct($total_size, $total_cap_used)/100);
}

sub process_args
{
    use vars qw( $opt_help );

    Getopt::Long::Configure("no_ignore_case", "bundling");
    GetOptions( "help" );

    if($opt_help)
    {
        print_help();
        exit(0);
    }

    # there should be at least two remaining arguments (file names)
    if($#ARGV < 1)
    {
        print "Error: invalid arguments.\n";
        print_help();
        exit(1);
    }

    @csv_files = @ARGV;

    return;
}

sub print_help
{
    print <<EOF;

Usage: $PROGRAM_NAME file file [file ...]

    --help          Prints this help message

Purpose:

    This script reads multiple csv files generated by fsstats 1.4.5 and
    merges the statistics into a single csv file which is printed to stdout.

EOF
    return;
}

# add_summary()
# adds summary fields from the specified file handle
#
sub add_summary
{
    my ($file) = @_;
    my $line = "";
    my $version = "";

    seek($file, 0, 0);

    while($line = <$file>) 
    {
        if ($line =~ /Generated by fsstats v(.*) /) { $version = $1; }
        if ($line =~ /^skipped special files,(.*)/) {$special_files += $1;}
        if ($line =~ /^skipped duplicate hardlinks,(.*)/) {$skipped_hlink += $1;}
        if ($line =~ /^skipped snapshot dirs,(.*)/) {$skipped_snapshot += $1;}
        if ($line =~ /^total capacity used,(.*)/) {$total_cap_used += print_to_kb($1);}
        if ($line =~ /^total user data,(.*)/) {$total_size += print_to_kb($1);}
    }

    if($version ne "1.4.5")
    {
        die("Error: csv file not generated by fsstats v1.4.5.\n");
    }
    seek($file, 0, 0);
}

# convert a printable value to KB
sub print_to_kb {
    my ($arg) = @_;
    my ($value, $unit) = split(/ /, $arg);
    my $num = 0;

    if($unit eq "TB")
    {
        $num = $value * (1024*1024*1024);
    }
    elsif($unit eq "GB")
    {
        $num = $value * (1024*1024);
    }
    elsif($unit eq "MB")
    {
        $num = $value * (1024);
    }
    elsif($unit eq "KB")
    {
        $num = $value;
    }

    return $num;
}

# The routines in this section were taken directly from fsstats 1.4.5 by 
# Marc Unangst <munangst@panasas.com> and Shobhit Dayal
# <sdayal@andrew.cmu.edu>
#######################################################################

# Compute the percent overhead for a given capacity-used and size.
# This method of computing overhead computes "percentage of the
# capacity used that is overhead" and ranges from 0% (no overhead) to
# 100% (size==0 and cap>0, space is all overhead).
sub ovhd_pct {
    my ($size, $cap) = @_;

    if ($cap == 0) {
    return 0;
    }
    return (($cap - $size)/$cap)*100;
}

# convert a KB value to a "printable" value (GB, MB, or KB) depending
# on its magnitude. returns a string suitable for printing.
sub kb_to_print {
  my ($kb) = @_;
  my $num;
  my $unit;
  
  if($kb > 1024*1024*1024) {
    $num = $kb / (1024*1024*1024);
    $unit = "TB";
  }
  elsif($kb > 1024*1024) {
    $num = $kb / (1024*1024);
    $unit = "GB";
  }
  elsif($kb > 1024) {
    $num = $kb / 1024;
    $unit = "MB";
  }
  else {
    $num = $kb;
    $unit = "KB";
  }
  return sprintf("%.2f %s", $num, $unit);
}

#######################################################################
